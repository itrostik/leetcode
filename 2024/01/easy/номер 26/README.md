Из целочисленного массива nums, отсортированного в неубывающем порядке, удалите дубликаты на месте так, чтобы каждый уникальный элемент встречался только один раз. Относительный порядок элементов должен остаться прежним. Затем верните количество уникальных элементов в nums.

Если считать, что количество уникальных элементов в nums равно k, то для его получения необходимо выполнить следующие действия:

Изменить массив nums таким образом, чтобы первые k элементов nums содержали уникальные элементы в том порядке, в котором они присутствовали в nums изначально. Остальные элементы nums не важны, как и размер nums.
Возвращаем k.
Пользовательский судья:

Судья проверит ваше решение с помощью следующего кода:

int[] nums = [...]; // Входной массив
int[] expectedNums = [...]; // Ожидаемый ответ с правильной длиной

int k = removeDuplicates(nums); // Вызывает вашу реализацию

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
assert nums[i] == expectedNums[i];
}
Если все утверждения пройдут, то ваше решение будет принято.



Пример 1:

Вход: nums = [1,1,2]
Выходные данные: 2, nums = [1,2,_]
Пояснения: Ваша функция должна вернуть k = 2, при этом первые два элемента nums будут 1 и 2 соответственно.
Неважно, что вы оставите за пределами возвращаемого k (следовательно, это знаки подчеркивания).
Пример 2:

Вход: nums = [0,0,1,1,1,2,2,3,3,4]
Выход: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Пояснения: Ваша функция должна вернуть k = 5, при этом первые пять элементов nums будут 0, 1, 2, 3 и 4 соответственно.
Неважно, что вы оставите за пределами возвращаемого k (следовательно, это подчеркивания).

[Ссылка на задачу](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)